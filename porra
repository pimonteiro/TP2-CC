diff --git a/client.py b/client.py
index 74cb0c4..b761e0e 100644
--- a/client.py
+++ b/client.py
@@ -1,8 +1,9 @@
 
-from transfereCC import *
+import connection
 
 
-connection = startConnection("127.0.0.1", 12000, "Luis", "123", "download", "bicho", 1)
+conn = connection.Connection(destIP="127.0.0.1", destPort=12000, sourceIP="", sourcePort="")
+conn.connect(username="luis",password="123", action="get", filename="ficheiro")
 print(connection)
 
 
diff --git a/connection.py b/connection.py
index 11e4ccf..2008d2f 100644
--- a/connection.py
+++ b/connection.py
@@ -1,10 +1,65 @@
-class connectionStatus:
-    def __init__(self, destIP, destPort, sourceIP, sourcePort, nPackets):
+import message
+
+
+class ConnectionException(Exception):
+    pass
+
+
+class Connection:
+    def __init__(self, destIP, destPort, sourceIP, sourcePort):
         self.destIP = destIP
         self.destPort = destPort
         self.sourceIP = sourceIP
         self.sourcePort = sourcePort
-        self.datagrams[nPackets]
-        self.missing[0]
+        self.__socket = None
+
+    def connect(self, username, password, action, filename):
+        if self.__socket is not None:
+            raise ConnectionException('Conexão previamente estabelecida')
+
+        msg = message.ConnectionMessage(username=username, password=password, action=action, filename=filename)
+
+    def close(self):
+        if self.__socket is None:
+            raise ConnectionException('Conexão não foi previamente estabelecida')
+        # TODO ENVIAR ALGO ....
+        self.__socket.close()
+        self.__socket = None
+
+    def __str__(self):
+        value = \
+        {
+            "destIP": destIP,
+            "destPort": destPort,
+            "sourceIP": sourceIP,
+            "sourcePort": sourcePort,
+            "connected": self.__socket is not None
+        }
+
+        return "connection:" + str(value)
+
+
+
+
+# Função que estabelece os requisitos que o cliente envia ao servidor para estabelecer a conexão
+def startConnection(serverName, serverPort, username, password, action, fileName):
+
+    sendMessage(connection, startConnectionMessage) #envia a mensagem de ligação
+
+    message, address = recvMessage(connection)
+
+    assert connection['address'] == address
+    connection['totalSegments'] = message['totalSegments']
+
+    return connection
+
+
+
+def acceptConnection(connection):
+    acceptConnectionMessage = {'header': header(0, TYPESYN, 0), 'content': {}}
 
+    content = {}
+    content['totalSegments'] = 0
+    acceptConnectionMessage['content'] = content
 
+    sendMessage(connection, acceptConnectionMessage)
diff --git a/message.py b/message.py
index aef42e4..b2ac0fb 100644
--- a/message.py
+++ b/message.py
@@ -3,7 +3,7 @@ class ConnectionMessage:
 
     TYPE = 1
 
-    def __init__(self):
+    def __init__(self, username, password, action, filename):
         self.messsage =\
         {
             "header":
@@ -15,74 +15,108 @@ class ConnectionMessage:
             },
             "payload":
             {
-                "username": "",
-                "password": "",
-                "action": "",
-                "filename": ""
+                "username": username,
+                "password": password,
+                "action": action,
+                "filename": filename
             }
         }
 
 
-
 # mensagem cliente -> servidor (recebeu numero de segmentos) (2)
-class ConnectionMessage:
+class AckClientMessage:
+
+    TYPE = 2
+
+    def __init__(self):
+        self.messsage =\
+        {
+            "header":
+            {
+                "checksum": "",
+                "type": AckClientMessage.TYPE,
+                "nsequence": "",
+                "size": "" #(cabeçalho + payload)
+            },
+        }
 
-{
-    "header" : {
-        "checksum" : "",
-        "type" : "ACK",
-        "nsequence" : "",
-        "size" : "" #(cabeçalho + payload)
-    }
-}
 
 # mensagens servidor -> cliente com dados (3)
-{
-    "header" : {
-        "checksum" : "",
-        "type" : "", #no caso do ultimo segmento vai um FIN
-        "nsequence" : "",
-        "size" : "" #(cabeçalho + payload)
-    },
+class DataMessage:
+
+    TYPE = 3
+
+    def __init__(self):
+        self.message =\
+        {
+            "header":
+                {
+                    "checksum": "",
+                    "type": DataMessage.TYPE,  #no caso do ultimo segmento vai um FIN
+                    "nsequence": "",
+                    "size": ""  # (cabeçalho + payload)
+                },
+            "payload": "data"
+        }
 
-    "payload" : "data"
-}
 
 # primeira mensagem servidor -> cliente (4)
-{
-    "header" : {
-        "checksum" : "",
-        "type" : "",
-        "nsequence" : "",
-        "size" : "" #(cabeçalho + payload)
-    },
-
-    "payload" : {
-        "total segments" : ""
-    }
-}
+class TotalSegMessage:
+
+    TYPE = 4
+
+    def __init__(self):
+        self.message =\
+        {
+            "header":
+                {
+                    "checksum": "",
+                    "type": TotalSegMessage.TYPE,
+                    "nsequence": "",
+                    "size": ""  # (cabeçalho + payload)
+                },
+            "payload":
+            {
+                "totalSegments": ""
+            }
+        }
+
 
 # mensagem cliente -> servidor (missing) (5)
-{
-    "header" : {
-        "checksum" : "",
-        "type" : "",
-        "nsequence" : "",
-        "size" : "" #(cabeçalho + payload)
-    },
-
-    "payload" : {
-        "missing" : []
-    }
-}
+class MissingMessage:
+
+    TYPE = 5
+
+    def __init__(self):
+        self.message = \
+            {
+                "header":
+                    {
+                        "checksum": "",
+                        "type": MissingMessage.TYPE,
+                        "nsequence": "",
+                        "size": ""  # (cabeçalho + payload)
+                    },
+                "payload":
+                    {
+                        "missing": []
+                    }
+            }
+
 
 # utima mensagem cliente -> servidor (6)
-{
-    "header" : {
-        "checksum" : "",
-        "type" : "FIN",
-        "nsequence" : "",
-        "size" : "" #(cabeçalho + payload)
-    }
-}
+class FinMessage:
+
+    TYPE = 6
 
+    def __init__(self):
+        self.messsage =\
+        {
+            "header":
+            {
+                "checksum": "",
+                "type": FinMessage.TYPE,
+                "nsequence": "",
+                "size": "" #(cabeçalho + payload)
+            },
+        }
\ No newline at end of file
diff --git a/server.py b/server.py
index d22a880..9412398 100644
--- a/server.py
+++ b/server.py
@@ -2,38 +2,36 @@ from socket import *
 
 from transfereCC import *
 
-import json
 
-
-serverPort = 12000
-
-
-def createSynAck():
-    synAck = {'header': header(0,1,1), 'totalSegments': 100, 'content': {}}
-
-    return synAck
+# import nome do import transferCC.nomedafuncao
 
 
 #inicio da conexão adaptar as funções do recvfrom(2048) e do sendto() - estas funcoes podem ter de estar no transfereCC
-def startServer():
-
-    serverSocket = socket(AF_INET, SOCK_DGRAM)
+def startServer(port):
 
-    serverSocket.bind(('', serverPort))
+    socketConnection = socket(AF_INET, SOCK_DGRAM)
+    socketConnection.bind(('', port))
+    connection = createConnectionObject(socketConnection, ('*', port))
 
-    synAck = createSynAck()
+    while True:
+        message, address = recvMessage(connection)
+        if message['header']['type'] == TYPESYN:
+            newConnection = createConnectionObject(socketConnection, address)
+            # Verifica:
+            #   Usuario/Senha
+            #   Ficheiro
+            #   Se alguma coisa estiver errada nao aceita conexao
+            #   e envia um FIN. Caso contratrio prossegue com um
+            #   SIN.
 
-    print(synAck)
+            # Guardar a new connection num mapping (i.e. cache)
+            acceptConnection(newConnection)
+            print("Type syn")
+        if message['header']['type'] == TYPENORMAL:
+            print("Type normal")
 
-    clientMsg = rcvMsgFromClient(serverSocket)
 
-    sendMsgToClient(synAck, clientMsg)
 
 
-    return serverSocket
-
-
-
-
-
-serverSocket = startServer()
\ No newline at end of file
+serverPort = 12000
+serverSocket = startServer(serverPort)
\ No newline at end of file
diff --git a/transfereCC.py b/transfereCC.py
index 9402f39..cec8a3b 100644
--- a/transfereCC.py
+++ b/transfereCC.py
@@ -9,25 +9,6 @@ MAX_MESSAGE_SIZE = PDU = 2048  #packet data unit
 
 HEADBYTES = 20 #tem de ser fixo para se poder calcular a quantidade de pacotes, mas não precisa de ser 20
 
-TYPESYN = 1
-
-TYPEFIN = 2
-
-TYPELOST = 3
-
-TYPENORMAL = 4
-
-
-def createConnectionObject(socketConnection, address):
-    connection = {
-        'socket': socketConnection,
-        'address': address,
-        'totalSegments': 0
-    }
-
-    return connection
-
-
 # Função que estabelece o número de segmentos que vão ser enviados
 def total_Segments(data):
     if (data % (PDU + HEADBYTES)) != 0:
@@ -37,69 +18,6 @@ def total_Segments(data):
 
     return segments
 
-
-# Função que define o conteúdo do cabeçalho
-def header(checksum, type, n_sequence):
-    head = {}
-    head['checksum'] = checksum
-    if type == 3:
-        lista = [] # vai ter função do estado
-        head['type'] = "3," + ",".join(str(x) for x in lista)
-    else:
-        head['type'] = str(type)
-
-    head['n_sequence'] = n_sequence
-
-    return head
-
-# Criação da mensagem a ser enviada pelo cliente para estabelecer conexão
-def createConnectionMsg(username, password, action, fileName):
-    connectionMessage = {'header': header(0, TYPESYN, 0), 'content': {}}
-
-    content = {}
-    content["username"] = username
-    content["password"] = password
-    content["action"] = action  # upload ou download
-    content["fileName"] = fileName
-
-    connectionMessage['content'] = content
-
-    return connectionMessage
-
-
-# Função que estabelece os requisitos que o cliente envia ao servidor para estabelecer a conexão
-def startConnection(serverName, serverPort, username, password, action, fileName):
-    socketConnection = socket(AF_INET, SOCK_DGRAM) #cria um socket UDP
-
-    connection = createConnectionObject(socketConnection, (serverName, serverPort))
-
-    startConnectionMessage = createConnectionMsg(username, password, action, fileName)
-
-    sendMessage(connection, startConnectionMessage) #envia a mensagem de ligação
-
-    message, address = recvMessage(connection)
-
-    assert connection['address'] == address
-    connection['totalSegments'] = message['totalSegments']
-
-    return connection
-
-
-# Fecha a conexão
-def closeConnection(connection):
-    connection["socket"].close()
-
-
-def acceptConnection(connection):
-    acceptConnectionMessage = {'header': header(0, TYPESYN, 0), 'content': {}}
-
-    content = {}
-    content['totalSegments'] = 0
-    acceptConnectionMessage['content'] = content
-
-    sendMessage(connection, acceptConnectionMessage)
-
-
 # Envia mensagem para o cliente (o address tem o IP do cliente e a porta)
 def sendMessage(sock, addr, message):
     bytesMessage = json.dumps(message).encode()
